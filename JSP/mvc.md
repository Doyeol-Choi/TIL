# MVC (Model, View, Controller)
* 정보를 보여주는 부분 (View), 정보를 처리하는 부분 (Controller), 정보를 저장하거나 꺼내오는 부분 (Model) 3 개의 파트로 나눠서 프로그래밍하는 방법을 MVC 패턴이라고
한다.

* 모델1 과 모델2를 볼 수 있는데, 모델1의 경우 View와 Controller의 경계가 없이 사용하는 것을 말하는데 현재는 소규모 프로젝트 정도만 사용된다.

* 모델2의 경우 VIew와 Controller를 나눠서 화면을 처리하기 위한 부분(프레젠테이션 로직)과 실제 업무를 처리하는 부분(비즈니스 로직)를 통제하기 위한 컨트롤러로 분업하는 형태를 의미한다.
  - 모델2는 하나의 컨트롤러가 모든 요청을 받아서 해당하는 서블릿에 연결해주는 형태를 가진다.

* MVC 패턴의 컨트롤러 : 서블릿
  - 웹 브라우저(클라이언트)의 요청을 받는다.
  - 웹 브라우저가 어떤 기능을 요청했는지 분석한다.
  - 분석된 요구사항을 바탕으로 필요한 비즈니스 로직을 처리하는 모델을 호출한다.
  - 모델로부터 전달 받은 결과물을 알맞게 가공한 다음, request 나 session 객체의 setAttribute 메소드를 사용하여 결과를 속성에 저장한다.
  - 웹 브라우저에 처리 결과를 보여 주기 위해 JSP 를 선택한다음 JSP 에 포워딩 한다.

* MVC 패턴의 뷰 : JSP
  - 일반 JSP 와 같은 역할을 하지만 대체로 컨트롤러로 부터 전달 받는 데이터를 사용해서 결과를 출력해주는 역할을 한다.

* MVC 패턴의 모델 : 자바클래스
  - 컨트롤러로부터 요청을 받는다.
  - 비즈니스 로직을 수행한다.
  - 수행 결과를 컨트롤러에게 전달한다.

---------------------------------------------------------
## 게시물 등록 시나리오
모델2 기반 게시판

1. 데이터베이스 구축(테이블 생성, 시퀀스 생성)
2. 샘플 데이터 삽입과 확인(commit)

3. DBCP 셋팅
4. 각종 라이브러리를 복사(OJDBC8,JSTL)

5. VO 객체 제작
6. DBManager 객체 제작(DB 연결과 해제)
7. DAO 객체를 제작
    - 싱글턴 패턴
    - 각 쿼리를 호출할 메서드
      + 모든 게시물 조회
      + 게시물 등록
      + 게시물 조회시 카운트 증가
      + 게시물 상세보기
      + 게시물 수정
      + 게시물 삭제
      + 게시물 암호 확인  
    <br>
8. CSS

9. 요청을 처리하기 위한 컨트롤러(BoardServlet)
10. 요청을 기능으로 연결시켜줄 클래스(ActionFactory)
11. 각 기능을 가진 클래스를 묶어줄 인터페이스(Action)

12. 모든 게시물 목록 보기 기능
    - 게시물 보기 기능을 처리할 클래스(Action을 구현받은 클래스)
    - 화면을 보여주기 위한 뷰  
    <br>

13. 글 등록
    - 폼 요청
      + 게시물 등록 폼을 보여주는 기능을 처리할 클래스 (Action을 구현받은 클래스)
      + 게시물 등록 폼을 보여주기 위한 뷰
    - 게시물 등록 요청
      + 게시물을 등록하기 위한 기능을 처리할 클래스(Action을 구현받은 클래스)
      + DB에 등록하기위한 DAO 메서드
      + 결과를 반환하기 위한 뷰(목록 보기)
    - 각 기능 클래스를 ActionFactory에 등록  
    <br>
  
14. 글 상세 보기(조회수 추가)
    - 게시물 상세 보기를 위한 기능을 처리할 클래스(Action을 구현받은 클래스)
    - DB에서 해당 게시글 정보를 알아오기 위한 DAO메서드
      - 조회수가 증가 DAO메서드
    - 해당 정보를 반영한 뷰
    - 기능클래스를 ActionFactory 등록  
    <br>

15. 수정/삭제를 체크하기 위한 암호 입력
    - 암호 체크 폼으로 이동하기 위한 기능을 처리한 클래스(Action을 구현받은 클래스)
    - 암호 체크 폼을 보여주기 위한 뷰 => javascript를 통한 새창 열기  
    <br>
    
    - 암호 체크 기능을 처리하기 위한 클래스
    - DB에서 암호를 확인하기 위한 DAO메서드
    - 암호 실패시 -> 암호 체크 폼으로 돌아가기
    - 암호 성공시 -> 체크 성공 뷰를 통해 수정 / 삭제 에 맞게 이동     
    <br>
  
16. 글 수정
    - 글 수정 폼으로 이동하기 위한 클래스
    - 글 수정 폼을 보여주기 위한 뷰 => 상세보기를 위해 만들었던 메소드 활용  
    <br>
    
    - 글 수정 기능을 위한 클래스
    - DB에 글 수정을 처리하기 위한 DAO 메서드
    - 글 수정 후 이동할 페이지 목록보기로 이동  
    <br>
    
    - ActionFactory에 클래스 등록  
    <br>

17. 글 삭제
    - 글 삭제 기능을 처리하기 위한 클래스(Action을 구현받은 클래스)
    - DAO 글 삭제 기능을 하기 위한 메서드
    - 글 삭제 후에는 목록 보기로 이동
    - ActionFactory에 클래스 등록  
    <br>

18. 페이징
    - 샘플 데이터를 많이 넣어놓는다 (1000개)
    - 알고리즘
    - 쿼리
    - DAO 쿼리에 맞는 메서드 추가
    - 기존 목록 보기 기능 클래스를 수정
    - 목록 뷰 페이지를 수정

---------------------------------------------------------
### 페이징 알고리즘
* 한 페이지에 나올 목록의 수가 10개로 가정

* 1 ~ 10 페이지를 섹션으로 나눔  
ex) 1~10은 1번 섹션, 11~20은 2번 섹션... 

* 알아야할 정보 (756번 게시물을 보고 싶다면)
  - 섹션 정보 : 8번 섹션 (701~800번째의 게시물들)
  - 페이지 정보 : 6번 페이지 (751~760번째의 게시물들)

* 조건절 (섹션 S = 8, 페이지 P = 6)
  - WHERE 글번호 BETWEEN 751 AND 760;
    + (S-1)x100 + (P-1)x10+1 ~ (S-1)x100 + (P)x10
  
  - WHERE 글번호 BETWEEN (S-1)x100+(P-1)x10+1 AND (S-1)x100+(P)x10;

* 글 번호 => ROWID => SELECT할 때마다 새롭게 조회

* 전체 쿼리
  - 1단계 : 전체 글을 조회해서 ROWID를 추출한다.
    ```sql
    SELECT * FROM boardTbl ORDER BY num DESC;
    -- boardTbl 테이블 명, num 컬럼명
    ```
  
  - 2단계 : ROWID를 포함한 조회문 작성
    ```sql
    SELECT ROWNUM as nick, num, name, email, pass, title, content, readcount, writedate FROM (SELECT * FROM boardTbl ORDER BY num DESC);
    ```
  
  - 3단계 : 위 조건을 제시
    ```sql
    SELECT * FROM (SELECT ROWNUM as nick, num, name, email, pass, title, content, readcount, writedate FROM (SELECT * FROM boardTbl ORDER BY num DESC)) WHERE nick BETWEEN (S-1)x100+(P-1)x10+1 AND (S-1)x100+(P)x10;
    ```

---------------------------------------------------------
# Ajax
* 기존의 HTTP 통신 => 비동기 통신

* Ajax => 동기 통신
  - 페이지 전체를 새로고침 하는 것이 아니라 페이지를 구성하는 일부 데이터만 전송하고 전달하는 방법

* 자바 스크립트를 활용한 기술이다.
  - 내부적으로 서버와 통신하는 기술
  - 그냥 자바 스크립트로만 하기 어렵기 때문에 jQuery 활용

* 서로 다른 프로그램언어 사이의 데이터 교환 수단
 - xml(과거) => json

 1. 클라이언트에서 서버로 "문자열"
 2. 클라이언트에서 서버로 "객체" => JSON

 3. 서버에서 클라이언트로 "문자열"
 4. 서버에서 클라이언트로 "객체" => JSON